# First run R/0_set_env.R & R/import/import_skinny_cow_2022.R
# 0.0) Install and load packages ####
if (!require(pacman)) install.packages("pacman")  # Install pacman if not already installed
pacman::p_load(data.table, 
               miceadds,
               pbapply, 
               future.apply,
               future,
               progressr,
               miceadds)

# 0.1) Set n_workers for parallel #####
n_workers<-14

# 0.2) Set project & directories #####
project<-era_projects$skinny_cow_2022

# Set directory for error and harmonization tasks
error_dir<-file.path(era_dirs$era_dataentry_prj,project,"data_issues")
if(!dir.exists(error_dir)){
  dir.create(error_dir,recursive=T)
}

# Set paths for compiled data (generated by import scripts)
data_dir_local<-era_dirs$era_masterdata_dir
data_dir_s3<-era_dirs$era_masterdata_s3

# 1) Load data ####
  # 1.1) Load era vocab #####
  # Get names of all sheets in the workbook
  sheet_names <- readxl::excel_sheets(era_vocab_local)
  sheet_names<-sheet_names[!grepl("sheet|Sheet",sheet_names)]
  
  # Read each sheet into a list
  master_codes <- sapply(sheet_names, FUN=function(x){data.table(readxl::read_excel(era_vocab_local, sheet = x))},USE.NAMES=T)
  
  # Read in codes and harmonization datasets
  EUCodes<-master_codes$prod
  MasterLevels<-master_codes$lookup_levels
  PracticeCodes<-master_codes$prac
  PracticeCodes1<-master_codes$prac
  TreeCodes<-master_codes$trees
  # 1.2) Load compiled excel data #####
  (files<-list.files(data_dir_local,project,full.names = T))
  (files_s3<-grep(project,s3$dir_ls(data_dir_s3),value=T))
  
  file_local<-tail(grep("RData",files,value=T),1)
  file_s3<-tail(grep("RData",files_s3,value=T),1)
    

  # If most recent compilation of the livestock is not available locally download it from the s3
  if(basename(file_local)!=basename(file_s3)){
    local_path<-gsub(data_dir_s3,data_dir_local,file_s3)
    s3$file_download(file_s3,local_path)
    files<-list.files(data_dir_local,project,full.names = T)
    file_local<-tail(grep("RData",files,value=T),1)
      }

  # Load data
  data_list<-miceadds::load.Rdata2(file=basename(file_local),path=dirname(file_local))
  
  AF.Out<-data_list$AF.Out
  Animals.Out<-data_list$Animals.Out
  Animals.Diet<-data_list$Animals.Diet
  Animals.Diet.Comp<-data_list$Animals.Diet.Comp
  Animals.Diet.Digest<-data_list$Animals.Diet.Digest
  Data.Out<-data_list$Data.Out[,N:=1:.N]
  MT.Out<-data_list$MT.Out
  Site.Out<-data_list$Site.Out
  Soil.Out<-data_list$Soil.Out
  Var.Out<-data_list$Var.Out
  
   # 1.2.1) Prepare Data.Out ######
  # Remove h-codes from T.Codes
  rm_code_fun<-function(x,delim,remove_pattern){
    x<-unlist(strsplit(x,delim))
    x<-x[!grepl(remove_pattern,x)]
    x<-x[!is.na(x)]
    x<-paste(sort(x),collapse = delim)
    return(x)
  }
  
  Data.Out[,Final.Codes:=T.Codes
  ][,Final.Codes:=rm_code_fun(Final.Codes[1],delim = "-",remove_pattern="h"),by=Final.Codes]
  Data.Out$Final.Codes<-strsplit(Data.Out$Final.Codes,"-")
  
  # Is Feed Substitution Present?
  check_codes<-master_codes$prac[Practice=="Feed Substitution",Code]
  Data.Out[,Feed.Sub:=any(unlist(Final.Codes) %in% check_codes),by=N]
  
  # Is Feed Addition Present?
  check_codes<-master_codes$prac[Practice=="Feed Addition",Code]
  Data.Out[,Feed.Add:=any(unlist(Final.Codes) %in% check_codes),by=N]
  
  # Remove NAs in diet controls
  Data.Out<-Data.Out[is.na(A.Feed.Sub.C),A.Feed.Sub.C:="No"][is.na(A.Feed.Add.C),A.Feed.Add.C:="No"]
  
  # Remove feed intake (strictly speaking this is not an ERA practice)
  feed_intake_data<-Data.Out[Out.Subind=="Feed Intake"]
  Data.Out<-Data.Out[Out.Subind!="Feed Intake"]
  
  # Change site buffer name
  setnames(Data.Out,"Buffer.Manual","Site.Buffer.Manual")
  
# 2) Automated Comparison of Control vs Treatments ####
  Comparison.List<-list()
  Verbose<-F
  Debug<-F
  # Ignore Aggregated Observations (dealt with in section 2.1 for additions)
  Data.Out.Animals<-Data.Out[!grepl("[.][.][.]",T.Name)]

  # Paper comparing animal breeds with an identical diet (base diet)
  if(F){
    unique(Data.Out.Animals[is.na(A.Level.Name),c("B.Code","T.Name","V.Animal.Practice","A.Level.Name")])
  }
  # Calculate Number of ERA Practices
  Data.Out.Animals[,N.Prac:=unlist(lapply(Final.Codes,length)),by=N]
  
  # Weight Gain Outcomes need non-essential info removing
  Data.Out.Animals[,Out.Code.Joined:=paste(as.vector(na.omit(c(Out.Subind[1],Out.Unit[1],Out.Depth.Upper[1],Out.Depth.Lower[1],Out.Group[1],Out.Partial.Outcome.Name[1],Out.NPV.Rate[1],Out.NPV.Time[1]))),collapse = ".."),by=Out.Code.Joined]
  
  # Set Grouping Variables
  grouping_cols<-c("Site.ID","P.Product","ED.Product.Comp","Time", "Out.Code.Joined",
                   "ED.Sample.Start","ED.Sample.End","ED.Sample.DAS","O.Structure","C.Structure","B.Code","Country")
  
  # 2.1) Feed Addition ####
  DATA<-Data.Out.Animals[(Feed.Add==T|A.Feed.Add.C=="Yes")]
  
  Match.Fun <- function(A, B) {
    A <- unlist(A)
    B <- unlist(B)
    result <- setdiff(A, B)
    if (length(result) == 0) {
      result <- NA
    }
    return(list(result))
  }
  Match.Fun2 <- function(A, B, C) {
    A <- unlist(A)
    B <- unlist(B)
    C <- unlist(C)
    result <- unique(C[match(A, B)])
    if (length(result) == 0) {
      result <- NA
    }
    return(list(result))
  }
    
  Compare.Fun.Ani<-function(Data,Verbose,Debug,PracticeCodes){
      
      BC<-Data$B.Code[1]
      N<-Data[,N]
      #Final.Codes<-Data[,Final.Codes] # Is this redundant?
      #k<-N # Is this redundant?
      Y<-Data[,c("Final.Codes","N","N.Prac")][,Y.N:=1:.N]
      
      result<-lapply(1:length(N),FUN=function(j){
        if(Verbose){
          output<-paste("N =",j)
          cat(paste(output, strrep(" ", 100 - nchar(output)), "\r"))
          flush.console()  
          }
        X<-unlist(Data$Final.Codes[j])
        i<-N[j]
        
        if(is.na(X[1])){
          Z<-Y[N!=i & !is.na(Final.Codes)
          ][,Match:=sum(X %in% unlist(Final.Codes)),by=N # How many practices in this treatment match practices in other treatments?
          ][,NoMatch:=sum(!unlist(Final.Codes) %in% X),by=N  # How many practices in this treatment do not match practices in other treatments?
          ][Match>=0 & NoMatch>0] # Keep instances for which this treatment can be a control for other treatments
          
          Z[,Control.Code:=rep(list(X),nrow(Z))] # Add codes that are present in the control
          
          Z[,Prac.Code:=list(Match.Fun(Final.Codes,Control.Code)),by=N  # Add in column for the codes that are in treatment but not control
          ][,Linked.Tab:=list(Match.Fun2(Control.Code,PracticeCodes$Code,PracticeCodes$Linked.Tab)),by=N
          ][,Linked.Col:=list(Match.Fun2(Control.Code,PracticeCodes$Code,PracticeCodes$Linked.Col)),by=N]
          
        }else{
          
          # Here we are working from the logic of looking at what other treatments can treatment[i] be a control for?
          Z<-Y[N!=i][,Match:=sum(X %in% unlist(Final.Codes)),by=N # How many practices in this treatment match practices in other treatments?
          ][,NoMatch:=sum(!unlist(Final.Codes) %in% X),by=N  # How many practices in this treatment do not match practices in other treatments?
          ][Match>=length(X) & NoMatch>0] # Keep instances for which this treatment can be a control for other treatments
          
          # There was a bug here where Control.Code was set to :=list(X), but if X was the same length as nrow(Z) this led to issues
          Z[,Control.Code:=rep(list(X),nrow(Z))] # Add codes that are present in the control
          
          Z[,Prac.Code:=list(Match.Fun(Final.Codes,Control.Code)),by=N  # Add in column for the codes that are in treatment but not control
          ][,Linked.Tab:=list(Match.Fun2(Control.Code,PracticeCodes$Code,PracticeCodes$Linked.Tab)),by=N
          ][,Linked.Col:=list(Match.Fun2(Control.Code,PracticeCodes$Code,PracticeCodes$Linked.Col)),by=N]
          
        }
        
        if(nrow(Z)>0){
          Z$Level.Check<-lapply(1:nrow(Z),FUN=function(ii){
            unlist(lapply(1:length(unlist(Z[ii,Linked.Tab])),FUN=function(jj){
              
              if(is.na(Z[ii,Linked.Tab])){TRUE}else{
                
                if(unlist(Z[ii,Linked.Tab])[jj]=="Animal.Out" & any(Z$Prac.Code[ii] %in% PracticeCodes1[Practice=="Feed Addition",Code])){
                  if(Verbose){print(paste0("Feed Add: ii = ",ii," | jj = ",jj))}
                  # Is the potential control listed as a control in the Animal tab?
                  Data_subset[j,A.Feed.Add.C]=="Yes"
                  # TO DO Advanced Logic: Control should contain all rows of treatment
                }else{
                  
                  if(unlist(Z[ii,Linked.Tab])[jj]=="Var.Out"){
                    if(Verbose){print(paste0("Improved Breed: ii = ",ii," | jj = ",jj))}
                    
                    COL<-unlist(Z[ii,Linked.Col])[jj]
                    if(!is.na(COL)){
                      # Does control value (left) equal treatment value (right)
                      Data[N==i,..COL] == Data[N== Z[ii,N],..COL]
                    }else{
                      # If control codes are NA (no ERA practice) then it could be comparible to other treatments that are not NA and have an ERA practice
                      !is.na(unlist(Z$Prac.Code)[ii])
                    }
                  }else{
                    if(Verbose){print(paste0("Simple: ii = ",ii," | jj = ",jj))}
                    
                    # Otherwise we assume comparison is valid
                    TRUE
                  }}}
              
              
            }))
            
          })
          
          # All Level.Checks must be true for comparison to be valid
          Z[,Level.Check:=all(unlist(Level.Check)),by=Y.N]
          
          if(Debug){
            Z
          }else{
            # Return rows from master table that are valid treatments for this control (Level.Check==T)
            Z[Level.Check==T,N]
          }
        }else{NA}
        
      })
      return(result)
    } # Setting Debug to T prints comparison table rather than row numbers
  
  CompareWithin<-grouping_cols

  B.Codes<-DATA[,unique(B.Code)]
  Comparisons <- pblapply(1:length(B.Codes), FUN = function(j) {
    
    BC <- B.Codes[j]
    
    # Filter Data_subset once using data.table's fast subset
    Data_subset <- DATA[B.Code == BC]
    
    # Vectorized comparison for the "CompareWithin" columns
    CW <- unique(Data_subset[, ..CompareWithin])
    CW.Match <- match(do.call(paste, Data_subset[, ..CompareWithin]), do.call(paste, CW))
    
    # Assign group by vectorized assignment
    Data_subset[, Group := CW.Match]
    
    # Process each unique group using rbindlist and lapply
    DS <- rbindlist(lapply(unique(Data_subset$Group), FUN = function(i) {
      
      if (Verbose) cat(paste0(BC, " Subgroup = ", i, "\n"))
      
      # Call the Compare.Fun.Ani function on each group
      Control.For <- Compare.Fun.Ani(Verbose = Verbose, Data = Data_subset[Group == i], Debug = FALSE, PracticeCodes = master_codes$prac)
      
      # Return the results as a data.table
      data.table(Control.For = Control.For, N = Data_subset[Group == i, N])
    }))
    
    # Add B.Code column after processing
    DS[, B.Code := BC]
    
    return(DS)
  })  
   
  # list studies with no comparisons
  error_dat<-data.table(B.Code=unique(rbindlist(Comparisons[unlist(lapply(Comparisons, FUN=function(X){all(is.na(X$Control.For))}))])$B.Code))
  error_dat<-error_dat[,value:=NA
                       ][,table:="Ani.Out"
                         ][,field:=NA
                           ][,issue:="Feed addition is present but there appear to be no valid comparisons."]
  errors<-list(error_dat)
  
  Comparisons<-rbindlist(Comparisons)
  Comparisons<-Comparisons[!is.na(Control.For)
  ][,Len:=length(unlist(Control.For)),by=N]
  
  Comparisons<-Comparisons[unlist(lapply(Comparisons$Control.For, length))>0]
  
  Cols<-c("T.Name")
  Cols1<-c(CompareWithin,Cols)
  
  Comparisons1<-Data.Out.Animals[match(Comparisons$N,N),..Cols1]
  Comparisons1[,Control.For:=Comparisons[,Control.For]]
  Comparisons1[,Control.N:=Comparisons[,N]]
  setnames(Comparisons1,"T.Name","Control.Trt")
  
  Comparisons1[,Compare.Trt:=paste0(Data.Out.Animals[match(unlist(Control.For),N),T.Name],collapse="//"),by=Control.N]
  Comparisons1[,Control.For:=paste0(unlist(Control.For),collapse="//"),by=Control.N][,Control.For:=as.character(Control.For)]
  
  Comparisons1$Analysis.Function<-"DietAdd"
  
  Comparison.List[["DietAdd"]]<-Comparisons1
  
  # 2.2) Feed.Add: Aggregated Practices ####
  # Ignore Aggregated Observations for now
  Data.Out.Animals.Agg<-Data.Out[grep("[.][.][.]",T.Name)]
  # Subset to Animal Data
  Data.Out.Animals.Agg<-Data.Out.Animals.Agg[!(is.na(A.Level.Name) & is.na(V.Animal.Practice)),]
  
  # Split codes into list
  Data.Out.Animals.Agg[,Final.Codes:=.(strsplit(T.Codes,"-")),by=N]
  
  # Calculate Number of ERA Practices
  Data.Out.Animals.Agg[,N.Prac:=length(unlist(Final.Codes)[!is.na(unlist(Final.Codes))]),by=N]
  
  # Is Feed Substitution Present?
  Data.Out.Animals.Agg[,Feed.Sub:=any(unlist(Final.Codes) %in% PracticeCodes1[Practice=="Feed Substitution",Code]),by=N]
  
  # Is Feed Addition Present?
  Data.Out.Animals.Agg[,Feed.Add:=any(unlist(Final.Codes) %in% PracticeCodes1[Practice=="Feed Addition",Code]),by=N]
  
  #  # Weight Gain Outcomes need non-essential info removing
  Data.Out.Animals.Agg[!is.na(Out.WG.Start) |
                     !is.na(Out.WG.Days)|
                     !is.na(Out.WG.Unit),
                   Out.Code.Joined:=paste(unlist(tstrsplit(Out.Code.Joined[1],"[.][.]",keep=1:2)),collapse=".."),by=Out.Code.Joined]
  
  # Set Grouping Variables
  CompareWithin<-c(grouping_cols,"T.Agg.Levels_name")
  
  Verbose<-F
  
  DATA<-Data.Out.Animals.Agg
  
  B.Codes<-DATA[,unique(B.Code)]
  Comparisons<-rbindlist(pblapply(1:length(B.Codes),FUN=function(i){
    BC<-B.Codes[i]
    Data_subset<-DATA[B.Code==BC]
    CW<-unique(Data_subset[,..CompareWithin])
    CW<-match(apply(Data_subset[,..CompareWithin], 1, paste,collapse = "-"),apply(CW, 1, paste,collapse = "-"))
    Data_subset[,Group:=CW]
    
    DS<-rbindlist(lapply(unique(Data_subset$Group),FUN=function(i){
      if(Verbose){
        outcome<-paste0(BC," Subgroup = ", i)
        cat(paste(output, strrep(" ", 100 - nchar(output)), "\r"))
        flush.console()  
        }
      
      Control.For<-Compare.Fun.Ani(Verbose = Verbose,Data = Data_subset[Group==i],Debug=F,PracticeCodes = master_codes$prac)
      data.table(Control.For=Control.For,N=Data_subset[Group==i,N])
    }))
    
    DS[,B.Code:=BC]
    DS
  }))
  
  Comparisons<-Comparisons[!is.na(Control.For)
  ][,Len:=length(unlist(Control.For)),by=N]
  
  Comparisons<-Comparisons[unlist(lapply(Comparisons$Control.For, length))>0]
  
  Cols<-c("T.Name")
  Cols1<-c(CompareWithin,Cols)
  
  Comparisons1<-Data.Out.Animals.Agg[match(Comparisons$N,N),..Cols1]
  Comparisons1[,Control.For:=Comparisons[,Control.For]]
  Comparisons1[,Control.N:=Comparisons[,N]]
  setnames(Comparisons1,"T.Name","Control.Trt")
  
  Comparisons1[,Compare.Trt:=paste0(Data.Out.Animals.Agg[match(unlist(Control.For),N),T.Name],collapse="//"),by=Control.N]
  Comparisons1[,Control.For:=paste0(unlist(Control.For),collapse="//"),by=Control.N][,Control.For:=as.character(Control.For)]
  
  Comparisons1$Analysis.Function<-"DietAdd.Agg"
  Comparisons1[,T.Agg.Levels_name:=NULL]
  Comparison.List[["DietAdd.Agg"]]<-Comparisons1
  
  # 2.3) Feed Substitution ####
  DATA<-Data.Out.Animals[Feed.Sub==T |A.Feed.Sub.C=="Yes"]
  
  Compare.Fun.Ani.DSub<-function(Data,Verbose,PracticeCodes){
    if(Verbose){
      output<-paste0(Data$B.Code[1], " | Group = ",unique(Data$Group))
      cat(paste(output, strrep(" ", 100 - nchar(output)), "\r"))
      flush.console()  
      }
    
    X<-which(Data$A.Feed.Sub.C=="Yes")
    
    if(length(X)==0){
      data.table(Control.For="No Feed Substitution Control Present",N=Data$N,B.Code=Data$B.Code[1])
    }else{
      
      if(length(unique(Data$V.Level.Name))>1){
        
        GI.Fun=function(FC){
          FC<-FC[FC %in% PracticeCodes[Practice == "Genetic Improvement",Code]]
          if(length(FC)==0){"Unimproved"}else{FC}
        }
        Data[,GI.Code:=GI.Fun(unlist(Final.Codes)),by=N]
        Data[is.na(V.Level.Name),V.Level.Name:="Blank"]
        
        Control.For<-lapply(X,FUN=function(i){
          # If control is unimproved it can be compared to any improved practice or unimproved if it has same breed
          Control<-Data[i]
          
          Control.For<-unlist(lapply((1:nrow(Data))[-i],FUN=function(j){
            Trt<-Data[j]
            
            # Variety codes are the same - comparison must be for Feed substitution only
            if(Trt$GI.Code == Control$GI.Code){
              # Check breeds are identical & feed sub is not a control
              if((Trt$V.Level.Name == Control$V.Level.Name) & (is.na(Trt$A.Feed.Sub.C)|Trt$A.Feed.Sub.C=="No")){
                Data[j,N]
              }else{
                NA
              }
              
            }else{
              if(Control$GI.Code == "Unimproved"){
                Data[j,N]
              }else{
                NA
              }
              
            }
            
          }))
          Control.For<-Control.For[!is.na(Control.For)]
          if(length(Control.For)==0){
            Control.For<-NA
          }
          Control.For
          
        })
        
        Z<-data.table(Control.For=Control.For,N=Data$N[X],B.Code=Data$B.Code[1])
        
      }else{
        
        Y<-Data[is.na(A.Feed.Sub.C)|A.Feed.Sub.C=="No",N]
        
        Z<-data.table(Control.For=list(as.character(NA)),N=Data$N[X],B.Code=Data$B.Code[1])
        Z[,Control.For:=list(Y)]
        
        
      }
      Z
    }
    
  }
  
  
  # Set Grouping Variables
  CompareWithin<-c(grouping_cols,"T.Agg.Levels_name")  
  
  B.Codes<-DATA[,unique(B.Code)]
  
  Comparisons<-rbindlist(pblapply(1:length(B.Codes),FUN=function(i){
    BC<-B.Codes[i]
    
    Data_subset<-DATA[B.Code==BC]
    CW<-unique(Data_subset[,..CompareWithin])
    CW<-match(apply(Data_subset[,..CompareWithin], 1, paste,collapse = "-"),apply(CW, 1, paste,collapse = "-"))
    Data_subset[,Group:=CW]
    
    DS<-rbindlist(lapply(unique(Data_subset$Group),FUN=function(i){
      if(nrow(Data_subset[Group==i])<=1){
        DS<-data.table(Control.For=NA,N=Data_subset[Group==i,N],B.Code=BC)
      }else{
        
        DS<-Compare.Fun.Ani.DSub(Verbose = Verbose,Data = Data_subset[Group==i],PracticeCodes1)
      }
      DS
    }))
    
    
    DS
    
  }))

  Comparisons[Control.For=="No Feed Substitution Control Present",Control.For:=NA]
  
  error_data<-Comparisons[,N.Comp:=length(!is.na(Control.For)),by=B.Code
                                       ][N.Comp==0,
                                         ][,.(value=NA),by=B.Code
                                           ][,table:="Ani.Out"
                                             ][,field:="A.Level.Name"
                                               ][,issue:="Feed substitution is present, but there appear to be no valid comparisons."]
  errors<-c(errors,list(error_dat))
  
  Comparisons<-Comparisons[!is.na(Control.For)
                           ][,Len:=length(unlist(Control.For)),by=N]
  
  Comparisons<-Comparisons[unlist(lapply(Comparisons$Control.For, length))>0]
  
  Cols<-c("T.Name")
  Cols1<-c(CompareWithin,Cols)
  
  Comparisons1<-Data.Out.Animals[match(Comparisons$N,N),..Cols1]
  Comparisons1[,Control.For:=Comparisons[,Control.For]]
  Comparisons1[,Control.N:=Comparisons[,N]]
  setnames(Comparisons1,"T.Name","Control.Trt")
  
  Comparisons1[,Compare.Trt:=paste0(Data.Out.Animals[match(unlist(Control.For),N),T.Name],collapse="//"),by=Control.N]
  Comparisons1[,Control.For:=paste0(unlist(Control.For),collapse="//"),by=Control.N][,Control.For:=as.character(Control.For)]
  Comparisons1$Analysis.Function<-"DietSub"
  Comparisons1[,T.Agg.Levels_name:=NULL]
  Comparison.List[["DietSub"]]<-Comparisons1
  
  # 2.4) Simple Comparisons #####
  Data.Out.No.Agg<-Data.Out[!grepl("[.][.][.]",T.Name)]
  # Remove outcomes aggregated over rot/int entire sequence or system (dealt with sections 1.2 and 1.3)
  Data.Out.No.Agg<-Data.Out.No.Agg[!is.na(T.Name)]
  # Remove animal data (dealt with in section 2)
  Data.Out.No.Agg<-Data.Out.No.Agg[Feed.Add==F & Feed.Sub==F]

  # Calculate Number of ERA Practices
  Data.Out.No.Agg[,N.Prac:=length(unlist(Final.Codes)[!is.na(unlist(Final.Codes))]),by="N"]

  # Weight Gain Outcomes need non-essential info removing
  
  # Weight Gain Outcomes need non-essential info removing
  Data.Out.Animals[,Out.Code.Joined:=paste(as.vector(na.omit(c(Out.Subind[1],Out.Unit[1],Out.Depth.Upper[1],Out.Depth.Lower[1],Out.Group[1],Out.Partial.Outcome.Name[1],Out.NPV.Rate[1],Out.NPV.Time[1]))),collapse = ".."),by=Out.Code.Joined]
  
  DATA<-Data.Out.No.Agg
  
  CompareWithin<-grouping_cols
  
  Match.Fun<-function(A,B){
    A<-unlist(A)
    B<-unlist(B)
    list(A[!A %in% B])
  }
  
  Match.Fun2<-function(A,B,C){
    A<-unlist(A)
    B<-unlist(B)
    C<-unlist(C)
    list(unique(C[match(A,B)]))
  }
  
  Compare.Fun<-function(Data,Verbose,Debug,PracticeCodes1,Return.Lists){
      BC<-Data$B.Code[1]
      N<-Data[,N]
      #Final.Codes<-Data[,Final.Codes] # Is this redundant?
      #k<-N
      Y<-Data[,c("Final.Codes","N","N.Prac")][,Y.N:=1:.N]
      
      rbindlist(lapply(1:length(N),FUN=function(j){
        if(Verbose){
          output<-paste(BC," - Group ",Data$Group[1]," - N =",j)
          cat(paste(output, strrep(" ", 100 - nchar(output)), "\r"))
          flush.console()  
          }
        X<-unlist(Data$Final.Codes[j])
        i<-N[j]
        
        if(is.na(X[1])){
          Z<-Y[N!=i & !is.na(Final.Codes)
          ][,Match:=sum(X %in% unlist(Final.Codes)),by=N # How many practices in this treatment match practices in other treatments?
          ][,NoMatch:=sum(!unlist(Final.Codes) %in% X),by=N  # How many practices in this treatment do not match practices in other treatments?
          ][Match>=0 & NoMatch>0] # Keep instances for which this treatment can be a control for other treatments
          }else{
            # Here we are working from the logic of looking at what other treatments can treatment[i] be a control for?
          Z<-Y[N!=i][,Match:=sum(X %in% unlist(Final.Codes)),by=N # How many practices in this treatment match practices in other treatments?
          ][,NoMatch:=sum(!unlist(Final.Codes) %in% X),by=N  # How many practices in this treatment do not match practices in other treatments?
          ]
          
          # Keep instances for which this treatment can be a control for other treatments
          Z<-Z[Match>=length(X) & NoMatch>0] 
          }
        
        if(nrow(Z)>0){

          Z[,Control.Code:=rep(list(X),nrow(Z))] # Add codes that are present in the control
          
          Z[,Prac.Code:=list(Match.Fun(Final.Codes,Control.Code)),by=N  # Add in column for the codes that are in treatment but not control
          ][,Linked.Tab:=list(Match.Fun2(Control.Code,PracticeCodes$Code,PracticeCodes$Linked.Tab)),by=N
          ][,Linked.Tab_prac:=list(Match.Fun2(Control.Code,PracticeCodes$Code,PracticeCodes$Linked.Tab)),by=N
          ][,Linked.Col:=list(Match.Fun2(Control.Code,PracticeCodes$Code,PracticeCodes$Linked.Col)),by=N]
          
          # Allow for control practices that are in the animal tab being compared to other practices in the animal tab
          # to have different A.Level.Names
          
          X<-Z[grepl("Animals.Out",Linked.Tab) & grepl("Animals.Out",Linked.Tab_prac),unlist(Linked.Col)]
          X<-list(X[X!="A.Level.Name"])
          Z[grepl("Animals.Out",Linked.Tab) & grepl("Animals.Out",Linked.Tab_prac),Linked.Col:=X]
          
          X<-Z[grepl("Animals.Out",Linked.Tab) & grepl("Animals.Out",Linked.Tab_prac),unlist(Linked.Tab)]
          X<-list(X[X!="Animals.Out"])
          Z[grepl("Animals.Out",Linked.Tab) & grepl("Animals.Out",Linked.Tab_prac),Linked.Tab:=X]
          
          Z[,Linked.Tab_prac:=NULL]
          
          Z$Level.Check<-lapply(1:nrow(Z),FUN=function(ii){
            if(length(unlist(Z[ii,Linked.Tab]))==0){
              !is.na(unlist(Z$Prac.Code)[ii])
            }else{
              unlist(lapply(1:length(unlist(Z[ii,Linked.Tab])),FUN=function(jj){
                                
                                if(Verbose){print(paste0("Simple: ii = ",ii," | jj = ",jj))}
                                
                                # Simple cases where the treatment level names need be identical for practices shared between control and treatment
                                # Control Field
                                COL<-unlist(Z[ii,Linked.Col])[jj]
                                if(!is.na(COL)){
                                  # Does control value (left) equal treament value (right)
                                  Data[N==i,..COL] == Data[N== Z[ii,N],..COL]
                                }else{
                                  # If control codes are NA (no ERA practice) then it could be comparible to other treatments that are not NA and have an ERA practice
                                  !is.na(unlist(Z$Prac.Code)[ii])
                                }
                              
                
              }))
            }
            
          })
          
          # All Level.Checks must be true for comparison to be valid
          Z[,Level.Check:=all(unlist(Level.Check)),by="Y.N"]
          
          if(Debug){
            Z
          }else{
            # Return rows from master table that are valid treatments for this control (Level.Check==T)
            
            Z<-Z[Level.Check==T,]
            if(nrow(Z)>0){
              if(!Return.Lists){
                data.table(N = Y[j,N],Control.For=Z[,N],B.Code=BC)
              }else{
                data.table(N = Y[j,N],Control.For=list(Z[,N]),B.Code=BC)
              }
            }else{}
          }
        }else{}
        
      }))
    } 

  B.Codes<-Data.Out.No.Agg[,unique(B.Code)]
  
  Comparisons<-pblapply(1:length(B.Codes),FUN=function(i){
      BC<-B.Codes[i]
      Data_subset<-DATA[B.Code==BC]
      CW<-unique(Data_subset[,..CompareWithin])
      CW<-match(apply(Data_subset[,..CompareWithin], 1, paste,collapse = "-"),apply(CW, 1, paste,collapse = "-"))
      Data_subset[,Group:=CW]
      
      results<-rbindlist(lapply(unique(Data_subset$Group),FUN=function(i){
        if(Verbose){print(paste0(BC," Subgroup = ", i))}
        Compare.Fun(Verbose = Verbose,Data = Data_subset[Group==i],Debug=F,PracticeCodes1=master_codes$prac,Return.Lists=F)
        }))
      
      return(results)
      
    })

  Comparisons<-unique(rbindlist(Comparisons))
  
  error_dat<-DATA[!B.Code %in% Comparisons[,B.Code] & A.Feed.Add.C!="Yes" & A.Feed.Sub.C!="Yes",.(value=paste(unique(T.Name),collapse = "/")),by=B.Code
                    ][,table:="MT.Out"
                      ][,field:="T.Name"
                        ][,issue:="No Comparisons available in treatments that have no addition or substitution role (i.e. will not be used in comparisons)."]
  
    errors<-c(errors,list(error_dat))
    
    # Restructure and save
    Comparisons<-Comparisons[!is.na(Control.For)
    ][,Len:=length(unlist(Control.For)),by=N]
    
    Comparisons<-Comparisons[unlist(lapply(Comparisons$Control.For, length))>0]
    
    Cols<-c("T.Name")
    Cols1<-c(CompareWithin,"T.Name")
    
    Comparisons1<-Data.Out.No.Agg[match(Comparisons[,N],N),..Cols1]
    Comparisons1[,Control.For:=Comparisons[,Control.For]]
    Comparisons1[,Control.N:=Comparisons[,N]]
    setnames(Comparisons1,"T.Name","Control.Trt")

    Comparisons1[,Compare.Trt:=Data.Out.No.Agg[match(Control.For,N),T.Name]]
    Comparisons1$Analysis.Function<-"Other"
    Comparison.List$Other<-Comparisons1
    
  # 2.5) Save Errors #####
    errors<-rbindlist(errors)
    error_list<-error_tracker(errors=errors,
                              filename = paste0("comparison_logic_errors"),
                              error_dir=error_dir,
                              error_list = list())
    
  # 2.6) Combine Data ####
  Comparisons<-rbindlist(Comparison.List)
  
  # Check for any funny business with very many comparisons -  JS0290
  Comparisons$Control.For.N<-unlist(lapply(Comparisons$Control.For,function(x){length(unlist(strsplit(x,"//")))}))
  unique(Comparisons[Control.For.N>10,.(B.Code,Analysis.Function,Control.For.N)])

# 3) Prepare Main Dataset ####
  Data<-Data.Out
  # 3.1) Add filler cols ####
  Data$LatM<-NA # All values converted to DD in excel
  Data$LatS<-NA # All values converted to DD in excel
  Data$LatH<-NA # All values converted to DD in excel
  Data$LonM<-NA # All values converted to DD in excel
  Data$LonS<-NA # All values converted to DD in excel
  Data$LonH<-NA # All values converted to DD in excel
  Data$LatDiff<-NA # I don't think this is needed as the Buffer.Manual field is calculated in the excel
  Data$Soil.Classification<-NA # Not collected deliberately
  Data$Soil.Type<-NA # Not collected deliberately
  Data[,USD2010.T:=NA] # TO DO: Needs function to calculate this automatically
  Data[,USD2010.C:=NA] # TO DO: Needs function to calculate this automatically
  Data[,MeanFlip:=NA] # Not sure what this is for, but all values in the Master dataset seem to say N
  
  # 3.2) MSP & MAT ####
  Data[,Season:=unlist(lapply(strsplit(Data[,Time],"[.][.]"),FUN=function(X){
    X<-unlist(strsplit(X,"[.]"))
    if(all(is.na(X))|is.null(X)){
      NA
    }else{
      if(any(X==1) & !any(X==2)){
        1
      }else{
        if(any(X==2) & !any(X==1)){
          2
        }else{
          NA
        }}}
  }))]
  Data[Season==1|is.na(Season),MSP:=Site.MSP.S1]
  Data[Season==2,MSP:=Site.MSP.S2]
  
  # 3.3) Soils ####
  Soil.Out[,Depth.Interval:=Soil.Upper-Soil.Lower]
  Soil.Out[Depth.Interval==0,Depth.Interval:=1]
  X<-Soil.Out[,list(SOC=round(weighted.mean(Soil.SOC,Depth.Interval,na.rm=T),2),Lower=max(Soil.Lower),Upper=min(Soil.Upper),SOC.Unit=unique(Soil.SOC.Unit),
                    Soil.pH=round(weighted.mean(Soil.pH,Depth.Interval,na.rm=T),2),Soil.pH.Method=unique(Soil.pH.Method)),by=c("B.Code","Site.ID")]
  Y<-Soil.Out[Soil.Lower<=50,list(SOC=round(weighted.mean(Soil.SOC,Depth.Interval,na.rm=T),2),Soil.pH=round(weighted.mean(Soil.pH,Depth.Interval,na.rm=T),2),
                                  Lower=max(Soil.Lower),Upper=min(Soil.Upper)),by=c("B.Code","Site.ID")]
  X[match(Y[,paste(B.Code,Site.ID)],paste(B.Code,Site.ID)),SOC:=Y[,SOC]]
  X[match(Y[,paste(B.Code,Site.ID)],paste(B.Code,Site.ID)),Soil.pH:=Y[,Soil.pH]]
  X[match(Y[,paste(B.Code,Site.ID)],paste(B.Code,Site.ID)),Upper:=Y[,Upper]]
  X[match(Y[,paste(B.Code,Site.ID)],paste(B.Code,Site.ID)),Lower:=Y[,Lower]]
  N.Match<-match(Data[,paste(B.Code,Site.ID)],X[,paste(B.Code,Site.ID)])
  Data[,SOC:=X[N.Match,SOC]]
  Data[,SOC.Depth:=X[,(Lower+Upper)/2][N.Match]]
  Data[,SOC.Unit:=X[N.Match,SOC.Unit]]
  Data[,Soil.pH:=X[N.Match,Soil.pH]]
  Data[,Soil.pH.Method:=X[N.Match,Soil.pH.Method]]
  rm(N.Match,X,Y)
  # 3.4) Create TID code ####
  Data[,TID:=paste0("T",as.numeric(as.factor(T.Name))),by="B.Code"]
  
  # 3.5) Make "C1:Cmax" & Add Base Codes ####
  # NOTE - SHOULD BASE ELEMENTS BE ADDED IN THE IMPORT??? ####
  Data[,Base.Codes:=strsplit(Base.Codes,"-")]
  Join.Fun<-function(X,Y){
    X<-unique(c(unlist(X),unlist(Y)))
    X<-X[order(X,decreasing = T)]
    if(all(is.na(X))){
      NA
    }else{
      return(X[!is.na(X)])
    }
  }
  
  Data[,All.Codes:=Data[,list(All.Codes=list(Join.Fun(Base.Codes,Final.Codes))),by=N][,All.Codes]]
  
  X<-rbindlist(pblapply(Data[,All.Codes],FUN=function(X){data.table(t(data.table(X)))}),fill=T)
  colnames(X)<-paste0("C",1:ncol(X))
  
  Data<-cbind(Data,X)
  
  # TO DO - Which studies have >11 practices - Consider simplifying residues codes when Int/Rot are present (as per Basic Comparisons)
  Data[apply(X,1,FUN=function(Y){sum(!is.na(Y))})>10]
  
    # 3.5.1) How many C columns are there? ####
  NCols<-sum(paste0("C",1:30) %in% colnames(Data))
  
  if(NCols<10){
    cols<-paste0("C",(NCols+1):10)
    Data[,(cols):=NA]
  }
  
  NCols<-sum(paste0("C",1:30) %in% colnames(Data))
  
  # 3.6) Add in Trees ####
  # Trees from AF.Tab
  merge_dat<-AF.Out[,.(Trees=paste(sort(unique(trimws(unlist(strsplit(AF.Tree[!is.na(AF.Tree)],"[.][.]|;"))))),collapse = ";")),by=c("AF.Level.Name","B.Code")]
  Data<-merge(Data,merge_dat,by=c("AF.Level.Name","B.Code"),all.x=T,sort=F)
  # Trees from animal diet
  Data[A.Diet.Trees=="",A.Diet.Trees:=NA]
  Data[,Trees_both:=paste(sort(unique(c(unlist(strsplit(A.Diet.Trees[1],";")),unlist(strsplit(Trees[1],";"))))),collapse=";"),by=.(Trees,A.Diet.Trees)]
  
  # 3.7) M.Year/Season - Translate to old system or code start/end year and season ####
  # We have some instances of 2000-2020 and some of ".." and some of "-5" between seasons
  M.Year.Fun<-function(M.Year){
    X<-unlist(strsplit(M.Year,"[.]"))
    if(length(X)>4 & nchar(X[1])==4 & nchar(X[2])==1){
      X<-paste0(c(X[1],X[2],X[(length(X)-1)],X[length(X)]),collapse = ".")
    }else{
      if(length(X)>1 & nchar(X[1])==4 & nchar(X[2])==4){
        X<-paste0(c(X[1],X[length(X)]),collapse = ".")
      }else{
        X<-paste0(X,collapse=".")
      }
    }
    
    return(X)
  }
  
  M.Start.Fun<-function(M.Year){
    X<-unlist(strsplit(M.Year,"[.]"))
    X<-as.integer(X[1])
    return(X)
  }
  
  M.End.Fun<-function(M.Year){
    X<-unlist(strsplit(M.Year,"[.]"))
    X<-X[nchar(X)==4]
    X<-as.integer(X[length(X)])
    return(X)
  }
  
  M.S.Start.Fun<-function(M.Year){
    X<-unlist(strsplit(M.Year,"[.]"))
    X<-X[nchar(X)==1]
    X<-as.integer(X[1])
    return(X)
  }
  
  M.S.End.Fun<-function(M.Year){
    X<-unlist(strsplit(M.Year,"[.]"))
    X<-X[nchar(X)==1]
    X<-as.integer(X[length(X)])
    return(X)
  }
  
  Data[,M.Year:=gsub("..",".",Time,fixed=T)
       ][,M.Year:=gsub("-5","",M.Year)
         ][,M.Year:=gsub("-",".",M.Year)]
  
  Data[,M.Year:=M.Year.Fun(M.Year[1]),by=M.Year]
  Data[,M.Year.Start:=M.Start.Fun(M.Year[1]),by=M.Year]
  Data[,M.Year.End:=M.End.Fun(M.Year[1]),by=M.Year]
  Data[,M.Season.Start:=M.S.Start.Fun(M.Year[1]),by=M.Year]
  Data[,M.Season.End:=M.S.End.Fun(M.Year[1]),by=M.Year]
  Data[,Max.Season:=max(M.Season.Start),by=.(B.Code,Site.ID)]
  
  # 3.8) Calculate Duration ####
    # Get length of weight gain outcomes
    Data[,Duration:=mean(unique(Out.WG.Days[!is.na(Out.WG.Days)])),by=.(B.Code,T.Name)]

  # 3.9) Animal Diet Source ####
  X<-Animals.Diet[,list(Source=unique(D.Source)),by=c("B.Code","A.Level.Name")]
  NX<-match(Data[,paste(B.Code,A.Level.Name)],X[,paste(B.Code,A.Level.Name)])
  Data[,Feed.Source:=X[NX,Source]]
  # 3.10) TSP & TAP ####
  NX<-match(Data[,paste(B.Code,Site.ID,M.Year)],Times.Out[,paste(B.Code,Site.ID,Time)])
  Data[,TSP:=Times.Out[NX,TSP]]
  Data[,TAP:=Times.Out[NX,TAP]]
  rm(NX)
  
  # X) Aggregate data for averaged site locations -MOVE TO IMPORT SECTION ####
  if(F){
  setnames(Data,"Buffer.Manual","Site.Buffer.Manual")
  setnames(Site.Out,"Buffer.Manual","Site.Buffer.Manual")
  
  
  A.Sites<-Data[grepl("[.][.]",Site.ID),N]
  
  Agg.Sites<-function(B.Code,Site.ID,Site.Out){
    
    Sites<-unlist(strsplit(Site.ID,"[.][.]"))
    Study<-B.Code
    
    coords<-Site.Out[Site.ID %in% Sites & B.Code==Study,list(Site.LatD,Site.LonD,Site.Lat.Unc,Site.Lon.Unc,Site.Buffer.Manual)]
      coords[,N:=1:.N][is.na(Site.Buffer.Manual),Site.Buffer.Manual:=max(c(Site.Lat.Unc,Site.Lon.Unc)),by=N]
    
    coords<-coords[!(is.na(Site.LatD)|is.na(Site.LonD))]
    
    if(nrow(coords)==0){
      
      return(data.table(Site.LonD=as.numeric(NA),Site.LatD=as.numeric(NA),Site.Buffer.Manual=as.numeric(NA)))
      
    }else{
      
      points <- sp::SpatialPoints(coords[,list(Site.LonD,Site.LatD)],proj4string=sp::CRS("+init=epsg:4326"))
      points<-sp::spTransform(points,CRS("+proj=merc +lon_0=0 +k=1 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs"))
      
      pbuf1<-lapply(1:nrow(coords),FUN=function(i){
        pbuf<- gBuffer(points[i], widt=coords[i,Site.Buffer.Manual])
        pbuf<- spChFIDs(pbuf, paste(i, row.names(pbuf), sep="."))
        
      })
      
      pbuf1<-sp::SpatialPolygons(lapply(pbuf1, function(x){x@polygons[[1]]}),proj4string=sp::CRS("+proj=merc +lon_0=0 +k=1 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs"))
      
      X<-sp::bbox(pbuf1)
      Buff<-max(X[1,2]-X[1,1],X[2,2]-X[2,1])/2
      
      pbuf<-sp::spTransform(pbuf1,CRS("+init=epsg:4326"))
      Y<-sf::st_centroid(pbuf)
      
      return(data.table(Site.LonD=round(Y@coords[1],5),Site.LatD=round(Y@coords[2],5),Site.Buffer.Manual=round(Buff,0)))
    } 
  }
  
  X<-Data[A.Sites,Agg.Sites(B.Code[1],Site.ID[1],Site.Out),by=.(B.Code,Site.ID)]
  
  A.Sites<-match(Data[,paste(B.Code,Site.ID)],X[,paste(B.Code,Site.ID)])
  
  Data[!is.na(A.Sites),Site.LonD:=X[A.Sites[!is.na(A.Sites)],Site.LonD]]
  Data[!is.na(A.Sites),Site.LatD:=X[A.Sites[!is.na(A.Sites)],Site.LatD]]
  Data[!is.na(A.Sites),Site.Buffer.Manual:=X[A.Sites[!is.na(A.Sites)],Site.Buffer.Manual]]
  
  rm(A.Sites,Agg.Sites,X)
  
  unique(Data[is.na(Site.Buffer.Manual),list(B.Code,Site.ID,Site.LatD,Site.LonD,Site.Lat.Unc,Site.Lon.Unc,Site.Buffer.Manual)])
  }
  
  # 4.19) Update DOI field
  Data[is.na(B.DOI),B.DOI:=B.Url]
# 4) Reconfigure to ERA v1.0 format ####
  C.Descrip.Col<-"T.Name"
  
  C.Data.Cols<-c("B.Code","B.Author.Last","B.Date","B.Journal","B.DOI","Site.LatD","LatM","LatS","LatH","Site.LonD","LonM","LonS","LonH","LatDiff","Site.Elevation",
                 "Country","ISO.3166.1.alpha.3","Site.Type","Site.ID","Site.MAT","Site.MAP","TAP","MSP","TSP","Soil.Type","Soil.Classification","Site.Soil.Texture",
                 "SOC","SOC.Unit","SOC.Depth","Soil.pH","Soil.pH.Method","T.Reps","T.Animals",
                 "EX.Plot.Size","TID",C.Descrip.Col,paste0("C",1:NCols),"ED.Mean.T","ED.Error","ED.Error.Type",C.Descrip.Col,
                 "Site.Buffer.Manual","MeanFlip","Feed.Source","Out.Partial.Outcome.Name","Out.Partial.Outcome.Code")
  
  C.Cols<-c("Code","Author","Date","Journal","DOI","LatD","LatM","LatS","LatH","LonD","LonM","LonS","LonH","Lat.Diff","Elevation","Country","ISO.3166.1.alpha.3","Site.Type",
            "Site.ID","MAT","MAP","TAP","MSP","TSP","Soil.Type","Soil.Classification","Soil.Texture","SOC","SOC.Unit","SOC.Depth","Soil.pH","Soil.pH.Method",
            "Rep","Rep.Animals","Plot.Size","CID","C.Descrip",
            paste0("C",1:NCols),"MeanC","MeanC.Error","Mean.Error.Type","C.Descrip.Clean","Buffer.Manual","MeanFlip","C.Feed.Source","Partial.Outcome.Name","Partial.Outcome.Code")
  
  names(C.Data.Cols)<-C.Cols
  
  T.Descrip.Col<-"T.Name"
  
  T.Data.Cols<-c("TID",T.Descrip.Col,paste0("C",1:NCols),"V.Level.Name","Trees","Duration",
                 "M.Year","M.Year.Start","M.Year.End","M.Season.Start","M.Season.End","EU","Out.Code","Out.Unit","ED.Mean.T","ED.Error","Out.Depth.Upper","Out.Depth.Lower",
                 "ED.Data.Loc","USD2010.C","USD2010.T",T.Descrip.Col,"V.Level.Name","Trees","A.Diet.Trees","Feed.Source","V.Species")
  
  T.Cols<-c("TID","T.Descrip",paste0("T",1:NCols),"Variety","Tree.AF","Duration",
            "M.Year","M.Year.Start","M.Year.End","Season.Start","Season.End","EU","Outcome","Units","MeanT","MeanT.Error","Upper","Lower","DataLoc",
            "USD2010.C","USD2010.T","T.Descrip.Clean","Variety.Clean","Tree.AF.Clean","Tree.Feed","T.Feed.Source","Species")
  
  names(T.Data.Cols)<-T.Cols
  
  
Verbose<-F

Knit.V1<-function(Control.N,Control.For,Data,Analysis.Function,NCols,C.Data.Cols,T.Data.Cols){
  Control.N<-as.numeric(Control.N)
  
  Ctrl<-Data[N==Control.N,..C.Data.Cols]
  
  colnames(Ctrl)<-names(C.Data.Cols)
  
  Control.For<-as.numeric(unlist(strsplit(as.character(Control.For),"[/][/]")))
  
  Trt<-rbindlist(lapply(Control.For,FUN=function(i){
    X<-Data[N==i,..T.Data.Cols]
    colnames(X)<-names(T.Data.Cols)
    X
  }))
  
  Ctrl<-Ctrl[rep(1,nrow(Trt))]
  X<-cbind(Ctrl,Trt)
  X[,Analysis.Function:=Analysis.Function]
  X
  
}

ERA.Reformatted <-rbindlist(
      pblapply(1:nrow(Comparisons), function(i) {
      if (Verbose) {
        output <- paste(Comparisons[i, paste(B.Code, Control.N)], " | i = ", i,"/",nrow(Comparions))
        cat(paste(output, strrep(" ", 100 - nchar(output)), "\r"))
        flush.console()  
        }
      
      result <- Knit.V1(
        Control.N = Comparisons[i, Control.N],
        Control.For = Comparisons[i, Control.For],
        Data = Data,
        Analysis.Function = Comparisons[i, Analysis.Function],
        NCols = NCols,
        T.Data.Cols = T.Data.Cols,
        C.Data.Cols = C.Data.Cols
      )
      return(result)
    })
)

# Sanity Checks
dim(ERA.Reformatted)
table(ERA.Reformatted$Analysis.Function)
# Remove duplicate rows
ERA.Reformatted<-unique(ERA.Reformatted)
table(ERA.Reformatted$Analysis.Function)
dim(ERA.Reformatted)

ERA.Reformatted[,.(N.Obs=.N),by=.(Code,TID,Outcome,Units,Partial.Outcome.Name)][N.Obs>10][order(N.Obs,decreasing = T),.(Code,TID,Outcome,N.Obs)]
ERA.Reformatted[,.(N.Obs=.N),by=.(Code,CID,Outcome,Units,Partial.Outcome.Name)][N.Obs>10][order(N.Obs,decreasing = T),.(Code,CID,Outcome,N.Obs)]

  # x) Old Code (Move to import or remove)  ####
  
  if(F){
  # Change Kg to g
  Animals.Diet[,D.Amount:=as.numeric(D.Amount)]
  Animals.Diet[D.Unit.Amount=="kg",D.Amount:=D.Amount*1000]
  Animals.Diet[D.Unit.Amount=="kg",D.Unit.Amount:="g"]
  
  # Round amounts to 0 dp 
  Animals.Diet[,D.Amount.Round:=round(D.Amount)]

  # Deal with Diet Amount is na
  Animals.Diet[is.na(D.Amount),D.Amount.Round:=999999]
  # Deal with Diet Amount Rounded == 0  and Diet Amount Rounded is not zero
  Animals.Diet[D.Amount>0 & D.Amount.Round==0,D.Amount.Round:=999999]
  }

# 5) Save Output ####
save_name<-gsub("[.]RData","_comparisons.parquet",file_local)
arrow::write_parquet(ERA.Reformatted,save_name)
  
  